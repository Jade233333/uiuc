# hw13

## 1. Assembly program analysis

a)
iterate through the list and count the number of negative values
COUNT_RESULT stores the number of negative value

b)

| Label   | Address    |
|--------------- | --------------- |
| LOOP   | x3002   |
| SKIP_INC   | x3007   |
| FINISH   | x3009   |
| DATA_PTR   | x300B   |
| COUNT_RESUT   | x300C   |

## 2. String length calculation

a.i)
AND R0, R0, #0

a.ii)
BRz FINISH

a.iii)
ADD R1, R1, #1

a.iv)
ST R0, RESULT

b)

Messed up two things; first treated .ORIG x3000 as address x3000 and started counting at x3001. Second, when counting, treating the label as an independent address in fact they are lable to the lines after.

| Label   | Address    |
|--------------- | --------------- |
| LOOP   | x3002  |
| FINISH   | x3007   |
| STRING_PTR   | x3009   |
| RESULT   | x300A   |

## 3. Bug in left shift

a)
Line 7 branches depending on R1, however, R0 is in fact the counter for our loop. So it should check R0. Solve: swap line 5 and 6

Line 7 should be BRp SHIFT. Because couter starts at 5 and minus 1 each iteration it should loop whenver its postive not negative.

b)

| Label | address |
| -------------- | --------------- |
| SHIFT | x3002 |

## 4. Bugs in sign check

line 4 should be BRzp skip. When postive or zeor skip printing the message. When negative keep going to print the message.

## 5. Assembly program analysis

R4 = 325E
because of the ST command, line 5 is replaced with x192F. Treat it as a instruction and it is and ADD change only R4. So R4 is only doubled by line 6 in the end.

R4 = x327C
Not sure what I was thinking. I mentioned line 5 changes R4, but sounded like that I mean it was changing another register but not R4. Anyway, considering it chages R4 by `ADD R4, R4, #15`, R4 is now x193E, and then double it to x327C

## 6

a) o b) l c) `Hello World`
