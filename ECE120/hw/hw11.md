1. New ISA
ISA instructions can be broke down into different parts. For example, opcode-DR-SR1-SR2. We have 13 registers in total which means we need at least for 4 bits for each register. However, 4 bits can contain up to 16 registers. So we can make it 16 at no additional cost. Also some of the opcode are redundant. For example, we can make NAND with AND and NOT, NOR with OR and NOT, subtract with add. And if we can eliminate 5 opcodes we can make it to 32 opcodes in total which means 5 bits are enough to refer to all of them. Otherwise to contain all 37 opcodes we need one more bits. Which gives us 64 space in total where we waste a lot. In that case, we can make the final instruction 17 bits, 3x4bits for each register and 5 bits for opcode.

## Correction

Subtract can me removed, as it add with carry in and Not and replace it.
XOR, AND, OR, NOR, and NOT can also be removed, as NAND(or NOR) it self is logically complete.
to make it exactly 32, choice includes all five redundant logic OR Subtract and keep AND(or OR) and NOT to mantain the logical completeness and easiness to create Subtract

2. Address Space
2^18*8/64 = 2^15

3. BR instruction
current PC = x3101
a.
max offset = 01111111_2; x7F
largest Address: x3180
b.
max offset = 11111111_2; xFF
largest Address: x3200
c.
smallest address: x3101

4. NOR in LC-3
1001 100 100 111111    ; NOT R4, R4
1001 101 101 111111    ; NOT R5, R5
0101 001 100 0 00 101  ; AND R1, R4, R5

5. Code Analysis
0000 0000 0000 0011     ; This is the content of memory at address D
0000 0000 0000 0100     ; This is the content of memory at address D+1
; start LC-3 execution here
0010 101 111111110      ; R5 <- M[D+3 - x0002]; R5 <- x0004
0010 110 111111100      ; R6 <- M[D+4 - x0004]; R6 <- x0003

0101 111 111 1 00000    ; R7 <- R7 AND x0000; R7 <- x0000
0001 111 111 0 00 101   ; R7 <- R7 + R5; R7 <- x0004
0001 110 110 1 11111    ; R6 <- R6 - x0001; R6 <- x0002
0000 001 111111101      ; BRp -x0003

1110 110 111110111      ; R6 <- D+9 - x0009
0101 011 011 1 00000    ; R3 <- R3 AND X0000
0110 011 110 000000     ; R3 <- M[R6 + x0000]
; end LC-3 execution here

R3: x0003; lead with the memory in address R6, and R6 ends up in D, so R3 is x0003 which stored in address D
R5: x0004; not changed after the first load in address D+2
R6: D; it is first used as a counter in loop, and ends in x0000 after the loop. Then filled with a LEAD command which load current PC(D+9) minux x0009 where ends up in D
R7: x000C; add up by R5 after each loop. and R5 is intialized to x0004 before the loop. And R6, acts as the counter of the loop starting at x0003 and minus x0001 after each loop. The loop ends when R3 is no more positive. Which means it loops 3 times. So R7 is 3 times x0003 which is x000C

6. Code Analysis
LN ; start LC-3 execution here
1  0101 001 001 1 00000  ; AND R1, R1, x0000    ; R1 <- x0000
2  0001 001 001 1 00001  ; ADD R1, R1, x0001    ; R1 <- x0001
3  0101 010 010 1 00000  ; AND R2, R2, x0000    ; R2 <- x0000
4  0001 010 010 1 00001  ; ADD R2, R2, x0001    ; R2 <- x0001
5  1001 011 001 111111   ; NOT R3, R1           ; R3 <- NOT x0001 = xFFFE
6  1001 010 010 111111   ; NOT R2, R2           ; R2 <- NOT x0001 = xFFFE
7  0101 011 011 0 00 010 ; AND R3, R3, R2       ; R3 <- xFFFE AND xFFFE = xFFFE
8  1001 011 011 111111   ; NOT R3, R3           ; R3 <- NOT xFFFE = x0001
; end LC-3 execution here

a) R1: x0001; R2: xFFEE; R3: x0001
b) R3 <- R1 OR R2
